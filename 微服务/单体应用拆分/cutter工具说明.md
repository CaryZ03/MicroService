### cutter工具说明

### 数据收集

为了收集到单体应用完整的调用轨迹，我们使用了开源监控工具Kieker，并且在其基础上进行了相关改造以满足我们的需求。

Kieker是一个基于Java的应用性能监控和动态分析工具，它基于AOP的思想可以实现无侵入的应用监控，只需要进行简单的配置，无需修改业务代码即可获取到从API入口开始的方法调用链。同时，Kieker也有一系列分析工具来对监控到的数据进行分析和可视化，以帮助使用人员了解应用的运行时信息。

结合实际需求，我们只使用了Kieker的监控功能，并且在其基础上进行了相关改造：

1. 增加了场景概念，将方法调用链与场景相关联。
2. 监控应用执行的SQL语句，并将其整合到方法调用链中。

其中，场景和方法调用链的关联我们提供了两种途径：

1. 手工测试：使用者可以在一个页面输入将要测试的场景名称，点击开始，然后进行手工测试，测试完成之后点击停止。
2. 自动化测试：自动化测试以一组测试用例为一个场景，无需人工干预。

改造后的Kieker可以获取到应用的场景、方法调用链和SQL语句，Table的完整信息。监控到数据会以dat文件的格式被生成在执行目录。

*此处貌似可以写的更多一些* 

### 数据处理、分析

成功获取到完整的调用信息之后，我们实现了一个原型工具cutter来对数据进行处理、分析并得出相关拆分结果。

处理过程中我们使用Neo4j数据库来存储图结构，并且使用图分割算法来得到最终的拆分结果。

#### 场景驱动的调用轨迹图构建

首先，cutter会处理上一步得到的dat文件。首先在Neo4J数据库中生成所有的Method、SQL和Table节点，然后根据监控数据中的TraceId和调用序号和调用深度来建立节点之间的联系，最终生成以API为根的调用树组成的森林。

#### 提取共享表

在生成了场景驱动的调用轨迹图后，我们首先计算了所有数据表的共享程度，然后根据表的总数和共享表比例拟合曲线得到共享表，同时，我们也会寻找共享表之间的关联，关联比较强的共享表会被放在一组。

#### 表加权

加下来我们会根据两张表在场景中出现的情况，在同一条trace出现的情况和同一个SQL出现的情况来对表之间进行加权。

#### 图分割算法

对表进行加权之后我们可以得到一张表的权重图。然后我们使用相关的图分割算法来对表进行分割以得出相对较为合理的分割结果。

#### 向上追溯

在得到表拆分的结果之后，我们会从下倒上来进行追溯判定某个方法是直接归属于某个服务还是需要被拆分到两个服务中。



### 参考文献