<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Method Statistics And Exceptional Method Recording</title><link rel="stylesheet" type="text/css" href="../standalone/help_common.css"><link rel="stylesheet" type="text/css" href="../standalone/help.css"><script type="text/javascript">
helpId = 'jprofiler.advancedCpu.methodStatistics';
indexUrl= '../index.html';
</script><meta name="viewport" content="width=device-width, initial-scale=1"><script type="text/javascript" src="../standalone/jquery.min.js"></script><script type="text/javascript" src="../standalone/content.js"></script></head><body><div class="header-container"><div class="header-title"><h2>Method Statistics And Exceptional Method Recording</h2></div><div class="header-nav"><div class="nav-wrapper"><a class="nav-left" href="../advancedCpu/$folder$.html" title="key: j"></a></div><div class="nav-wrapper"><a class="nav-up" href="../advancedCpu/$folder$.html" title="key: u"></a></div><div class="nav-wrapper"><a class="nav-right" href="../advancedCpu/complexity.html" title="key: k"></a></div></div></div><hr><div class="spacer"></div><div>
    <p>
      In some situations, it's not the average invocation time of a method that is a problem, but rather
      that a method misbehaves every once in a while. In the call tree, all method invocations are cumulated, so
      a frequently called method that takes 100 times as long as expected once every 10000 invocations will not
      leave a distinct mark in the total times.
    </p>
    <p>
      To tackle this problem, JProfiler offers the method statistics view and the exceptional method recording feature
      in the call tree.
    </p>
    <h3>Method statistics view</h3>
    <p>
      The method statistics view shows information about the distribution of call durations to each method.
      With the histogram of all recorded call durations, you can check if you are dealing with single outliers
      or a continuous spectrum of durations. The standard deviation and the outlier coefficient that is calculated as
      <code>(maximum time - median time) / median time</code> can help you to quantify methods in this respect
      and sort them in the method table.
    </p>
    <p><img src="../images/ui/exceptional_method_statistics_view.png" alt="" onclick="showEnlarged(this)" class="scaledImg" style="vertical-align: middle; width: 100%; max-width: 984px"></p>
    <p>
      By default, the graph shows invocation counts on a logarithmic scale. This is ideal for identifying outliers with
      a low relative frequency. To get a feeling for the real numbers, it may be useful to switch to a linear axis in
      the view settings.
    </p>

    <h3>Configuring exceptional method recording</h3>
    <p>
      Once you have identified a method that suffers from exceptional call durations, you can add it as an exceptional
      method in the context menu. The same context menu action is also available in the call tree view.
    </p>
    <p><img src="../images/ui/exceptional_add_action.png" alt="" onclick="showEnlarged(this)" class="scaledImg" style="vertical-align: middle; width: 100%; max-width: 783px"></p>
    <p>
      When you register a method for exceptional method recording, a few of the slowest invocations will be retained
      separately in the call tree. The other invocations will be merged into a single method node as usual.
      The number of separately retained invocations can be configured in the profiling settings, by default it is
      set to 5.
    </p>
    <p>
      When discriminating slow method invocations, a certain thread state has to be used for the time measurement.
      This cannot be the thread status selection in the CPU views, because that is just a display option and not a
      recording option. By default, the wall clock time is used, but a different thread status can be configured
      in the profiling settings.
    </p>
    <p><img src="../images/ui/exceptional_profiling_settings.png" alt="" onclick="showEnlarged(this)" class="scaledImg" style="vertical-align: middle; width: 100%; max-width: 786px"></p>
    <p>
      In the session settings, you can remove exceptional methods or add new ones without the context of the call tree
      or the method statistics view. Also, the exceptional method configuration provides the option to
      add exceptional method definitions for well known systems, like the AWT and JavaFX event dispatch mechanisms
      where exceptionally long-running events are a major problem.
    </p>
    <p><img src="../images/ui/exceptional_config.png" alt="" onclick="showEnlarged(this)" class="scaledImg" style="vertical-align: middle; width: 100%; max-width: 736px"></p>

    <h3>Exceptional methods in the call tree</h3>
    <p>
      Exceptional method runs are displayed differently in the call tree view.
    </p>
    <p><img src="../images/ui/exceptional_call_tree_node.png" alt="" onclick="showEnlarged(this)" class="scaledImg" style="vertical-align: middle; width: 100%; max-width: 784px"></p>
    <p>
      The split method nodes have modified icons and show additional text:
    </p>
    <ul><li>
        <img src="../images/exceptional_16.png" alt="" srcset="../images/exceptional_16.png 1x,../images/exceptional_16@2x.png 2x" style="vertical-align: middle">&nbsp;<b>[exceptional run]</b><br>
        Such a node contains an exceptionally slow method run. By definition, it will have an invocation count of one.
        If many other method runs are slower later on, this node may disappear and be added to the
        "merged exceptional runs" node depending on the configured maximum number of separately recorded method runs.
      </li><li>
        <img src="../images/exceptional_merged_16.png" alt="" srcset="../images/exceptional_merged_16.png 1x,../images/exceptional_merged_16@2x.png 2x" style="vertical-align: middle">&nbsp;<b>[merged exceptional runs]</b><br>
        Method invocations that do not qualify as exceptionally slow are merged into this node. For any call stack,
        there can only be one such node per exceptional method.
      </li><li>
        <img src="../images/exceptional_current_16.png" alt="" srcset="../images/exceptional_current_16.png 1x,../images/exceptional_current_16@2x.png 2x" style="vertical-align: middle">&nbsp;<b>[current exceptional run]</b><br>
        If an invocation was in progress while the call tree view was transmitted to the JProfiler GUI,
        it was not yet known whether the invocation was exceptionally slow or not. The "current exceptional run" shows
        the separately maintained tree for the current invocation. After the invocation completes, it will either be
        maintained as a separate "exceptional run" node or be merged into the "merged exceptional runs" node.
      </li></ul>
    <p>
      Like for call tree splitting by <a href="../main/probes.html">probes</a> and
      <a href="../callTree/splitting.html">split methods</a>, an exceptional method node has a
      <i>Merge Splitting Level</i> action in the context menu that lets you merge and unmerge all invocations on the fly.
    </p>
    <p><img src="../images/ui/exceptional_merge_action.png" alt="" onclick="showEnlarged(this)" class="scaledImg" style="vertical-align: middle; width: 100%; max-width: 583px"></p>
  </div><br><hr><div class="header-container"><div class="header-nav"><div class="nav-wrapper"><a class="nav-left" href="../advancedCpu/$folder$.html" title="key: j"></a></div><div class="nav-wrapper"><a class="nav-up" href="../advancedCpu/$folder$.html" title="key: u"></a></div><div class="nav-wrapper"><a class="nav-right" href="../advancedCpu/complexity.html" title="key: k"></a></div></div></div></body></html>